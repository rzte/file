### GDB

设置Inter格式的汇编可在`~/.gdbinit`文件中添加`set disassemble-flavor intel`或者在gdb运行时执行此命令。

x（**examine**）可以查看特定地址内存：

```
(gdb) i r eip           # info register eip
eip            0x5655553a	0x5655553a <main+29>
(gdb) x/x 0x5655553a    # x 用来检查内存，是检查（examine）的简写，/后面的x代表16进制同时还有 d->十进制 o->八进制 u->无符号十进制 t->二进制 i->反汇编 c->ascii s->字符串
0x5655553a <main+29>:	0x00f445c7
(gdb) x/x $eip          # 除了可以直接跟地址之外，还可以用$直接引用寄存器
0x5655553a <main+29>:	0x00f445c7

```

其中，还可以在尾端添加一个字母来改变**examine**命令显示单位的大小：

- b 单个字节
- h 半字，两个字节
- w 字，四个字节
- g 巨型，八个字节

```
(gdb) x/xb $eip         # 显示单个字节
0x5655553a <main+29>:	0xc7
(gdb) x/8xb $eip        # 显示8组单个字节
0x5655553a <main+29>:	0xc7	0x45	0xf4	0x00	0x00	0x00	0x00	0xeb
(gdb) x/xg $eip         # 显示64位
0x5655553a <main+29>:	0xeb00000000f445c7
(gdb) x/8xg $eip        # 显示8组64位
0x5655553a <main+29>:	0xeb00000000f445c7	0xe5f0838d0cec8316
0x5655554a <main+45>:	0xfffffe5ee850ffff	0x8301f4458310c483
0x5655555a <main+61>:	0x0000b8e47e09f47d	0x5d5b59f8658d0000
0x5655556a <main+77>:	0x57559066c3fc618d	0x81fffffea7e85356
```
在x86中，数值以**little-endian**字节顺序存储的，也就是首先存储最低有效字节。所以上面查看一个字节显示的`0xc7`在查看多个字节时显示在最后面


使用**i**(**instruction**)可以将内存显示位反汇编后的汇编指令：

```
(gdb) x/i $eip              # 显示汇编
=> 0x5655553a <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
(gdb) x/3i $eip
=> 0x5655553a <main+29>:	mov    DWORD PTR [ebp-0xc],0x0
   0x56555541 <main+36>:	jmp    0x56555559 <main+60>
   0x56555543 <main+38>:	sub    esp,0xc
```

**print**会将结果存入一个临时变量中，从`$1`开始：

```
(gdb) print $ebp             # 查看ebp里的值
$4 = (void *) 0xffffd3e8
(gdb) x/8xw $4               # 查看0xffffd3e8的内存区域
0xffffd3e8:	0x00000000	0xf7df0e81	0xf7fad000	0xf7fad000
0xffffd3f8:	0x00000000	0xf7df0e81	0x00000001	0xffffd494
```

格式字母**c**可用于在**ASCII**表中自动查找一个字节，格式字符**s**可直接显示字符数据的整个字符串：

```
(gdb) print $ebx-0x1a10     # 将ebx-0x1a10存储至临时变量$5中
$5 = 1448433136
(gdb) x/8xb $5              # 打印8个字节
0x565555f0:	0x48	0x65	0x6c	0x6c	0x2c	0x20	0x77	0x6f
(gdb) x/8cb $5              # 打印出这8个字节的ascii码
0x565555f0:	72 'H'	101 'e'	108 'l'	108 'l'	44 ','	32 ' '	119 'w'	111 'o'
(gdb) x/8s $5               # 打印八个字符串
0x565555f0:	"Hell, world!\n"
0x565555fe:	""
0x565555ff:	""
0x56555600:	"\001\033\003;0"
0x56555606:	""
0x56555607:	""
0x56555608:	"\005"
0x5655560a:	""
```

`&`与`*`与C中用法相同

```
(gdb) list
4	int main(){
5		int int_var = 5;
6		int* int_ptr = &int_var;
7	}

(gdb) x/xw int_var 		# int_var中的值为5
0x5:	Cannot access memory at address 0x5
(gdb) x/xw &int_var 	# 取地址，x/xw打印里面的值
0xffffd104:	0x00000005
(gdb) print *int_ptr 
$1 = 5
```

### 存储器分段

已编译程序的存储器分为五段：**text**、**data**、**bss**、**heap**、**stack**段


![](/images/Sat-Jul--7-05:55:13-2018_462545.png)

#### text段

**text**段有时又被称为**代码段**，存储汇编后程序的机器语言指令的地方。程序执行时，EIP被设置为text段的第一条指令，然后按照循环做以下事情：
1. 读EIP指向的指令
2. 向EIP添加指令字节的长度
3. 执行第（1）步读取的指令
4. 循环123步

**text段禁用写权限**，因为该段不用来存储变量，只用来存储代码。这一存储段有**固定的大小**，因为它内部没什么可改变

#### data bss

**data**和**bss**段用来存储全局和静态程序变量。**数据段**中填充的是已经初始化的**全局变量和静态变量**，而**bss段**中填充的是与其对应的未初始化变量，虽然这些段是可以改写的，但他们也有**固定的大小**

在C语言中，编译的代码放入text段。定义在所有函数之外的变量被认为是全局变量。在任何变量前增加关键字static会使改变量成为静态变量。如果使用数据将静态变量或**初始化**了，它们就会存储在**data**内存段中，否则这些变量会存储在**bss**内存段中

### heap stack

**heap段**是一个程序设计人员可以直接控制的段。可以分配和使用这个段中的内存块。heap段的**大小是可变的**，也就是说**堆的大小可以根据需要改变**。**堆从存储器的低地址向高地址增长**

**stack段**的大小也是可变的，在函数调用期间，stack段被用作**中间结果暂存器**来存储本地函数变量和上下文。这就算GDB的回溯命令(bt full)所看到的。**堆栈用于存储所有被传递的变量、函数结束后EIP应该返回的位置以及所有局部变量**。所有这些信息一起存储在堆栈中被称为**栈帧**的地方。堆栈中包含许多栈帧















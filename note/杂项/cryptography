# 加密算法

## DES

DES是将64比特位加密成64比特的密文的对称密码算法，它的密钥长度是56比特。尽管从规格来说，DES密钥长度是64比特，但由于每隔7比特会设置一个用于错误检查的比特，因此实质上密钥长度是56比特

DES是以64比特（比特序列）为一个单位来进行加密的，这64个比特的单位成为分组。一般来说，以分组为单位进行处理的密码算法成为**分组密码（block cipher）**，DES就是分组密码中的一种。由于DES每次只能加密64比特的数据，如果要加密的明文比较长，就需要对DES加密进行迭代（反复），而迭代的具体方式称为**模式（mode）**

## 3DES

现在的DES已经可以在现实的时间内被暴力破解，3DES是为了增加DES的强度，将DES重复3此得到的一种密码算法，也成为TDEA（Triple Data Encryption Algorithm），通常缩写为3DES

为了兼容普通的DES，3DES采取的处理方式是 **加密 -> 解密 -> 加密**，如果传入的三次密钥都相同时，三重DES就等于普通的DES了。如果密钥1和密钥3使用相同的密钥，而密钥2使用不同的密钥（也就是只使用两个DES密钥），这种三重DES就称为DES-EDE2.EDE表示（Encryption）-> 解密（Decryption）->加密（Encryption）这个过程，密钥1、2、3全部使用不同的比特序列的三重DES称为DES-EDE3

## AES

AES（Advanced Encryption Standard）是取代前任标准DES而成为新标准的一种对称密码算法。在2000年从多种对称算法中选出了一种名叫**RijnDael**的对称密码算法，将其确定为AES

与DES一样，Rijndael算法也是由多个轮构成的，每一轮分为**SubBytes**、**ShiftRows**、**MixColumns**、**AddRoundKey**四个步骤。DES使用Feistel网络作为基本结构，而Rijndael没有使用Feistel网络，而是使用了**SPN**结构

## RSA

RSA是一种公钥密码算法，它的名字是由它的三位开发者Ron Rivest、Adi Shamir和Leonard Adleman的姓氏的首字母组成的

在RSA中，**明文**、**密钥**、**密文**都是数字，加密过程可以用下列公式来表述：

```
密文 = 明文^E mod N （RSA加密）
```

也就是说，RSA的密文是对代表明文的数字的E次方求mod N的结果，换句话说就是**将明文和自己做E次乘法，然后将其结果除以N求余数，这个余数就是密文**，其中的E（Encryption）和N（Number）组成公钥，一般写成“公钥是{E,N}”这样的形式

RSA的解密和加密的写法一样：

```
明文 = 密文^D mod N (RSA解密)
```

也就是对密文的数字的D次方就mod N就可以得到明文，这里的N和加密时使用的数字N时相同的，D和N组合起来就是RSA的解密密钥，也就是私钥

### 生成密钥对

E和N是公钥，D和N是私钥，因此求E、D、N这三个数就是生成密钥对。RSA密钥对生成步骤如下：

- 求N
	- 准备两个很大的质数p和q
		太小容易破译，太大计算时间会太长。假设生成p和q大小位512比特，可以先通过伪随机生成器生成一个512比特大小的数，再判断是不是质数，如果不是可以再生成一个（判断是不是质数的方法包括费马测试和米勒·拉宾测试等）
	- 将这两个数相乘，算出N来： N = p * q (p、q为质数)
- 求L（L是仅在生成密钥对的过程中使用的数）
	L在RSA加密和解密过程中都不出现，它只出现在生成密钥对的过程中。L是 p-1 和 q-1的最小公倍数（least common multiple，lcm）： L = lcm(p-1, q-1)
- 求E
	- E是一个比1大、比L小的数。此外，E和L的最大公约数（greatest common divisor，gcd）必须为1(也就是E和L互质)： 1 < E < L, gcd(E, L) = 1
	- 为了找到gcd(E, L)=1的数，可以使用伪随机数生成器在1~L的范围内生成E的候选数，然后再判断是否满足gcd(E, L)=1这个条件。（求最大公约数可以用欧几里得的辗转相除法）
	- 简单来说，**之所以加上E和L最大公约数为1的这个条件是为了保证一定存在解密时需要使用的数D**。至此已经求出了公钥
- 求D
	- D时通过E计算来的，D、E、L之间必须具备下列关系：
		```
		1 < D < L
		E * D mod L = 1
		```

1、求N | 3、求E
--|--
用伪随机数生成器求p和q，p、q互质; N = p * q | 1 < E < L; gcd(E, L)=1; E和L的最大公约数为1（E和L互质）
**2、求L** | **4、求D**
L = 1cm(p-1, q-1)；L是p-1和q-1的最小公倍数 | 1 < D < L； E * D mod L = 1

### 对RSA的攻击

- 通过暴力破解来找出D
	暴力破解的难度会随着D的长度增大而变大，当D足够长时，就不可能在现实时间中通过暴力破解找出D。现在，RSA中使用的p和q的长度都是**1024**比特以上的，N的长度为2048比特以上，由于E和D的长度可以和N长度差不多，因此要找出D就需要进行2048比特以上的暴力破解，在现实时间内时非常困难的
- 通过E和N求出D
	- 对N进行质因数分解攻击
		p和q不能被密码破译者知道，但是N=p*q，而且N是公开的（公钥{E, N}），p与q都是质数，因此由N求p和q只能通过将N进行质因数分解来完成，所以**一旦发现了对大整数进行质因分解的高效算法，RSA就能够被破译**
	- 通过推测P和Q进行攻击
		由于p和q是通过伪随机数生成器产生的，如果伪随机数生成器的算法很差，密码破译者就可能推测出来p和q，因此使用能够被推测出来的随机数是非常危险的
- 中间人攻击
	攻击者拦截请求，将自己的公钥发送给消息发送者，进行中间人攻击


### 其他公钥密码

RSA是现在最普及的一种公钥密码算法，但除了RSA之外还有其他公钥密码，如ElGamal方式、Rabin方式、椭圆曲线密码等

- ElGamal方式
	ElGamal方式是 Taher ElGamal设计的公钥算法。RSA利用了质因数分解的困难度，而ElGamal方式利用了 mod N下求离散对数的困难度。不过ElGamal方式有一个缺点，就是经过加密的密文长度会变为明文的两倍，密码软件GnuPG中就支持这种方式
- Rabin方式
	Rabin方式是由 M.O.Rabin 设计的公钥算法，Rabin方式利用了mod N下求平方根的困难度，而破译Rabin方式公钥密码的困难度与质因分解则是相当的，这一点已经得到证明
- 椭圆曲线密码
	椭圆曲线Elliptic Curve Cryptography，ECC）是最近备受关注的一种公钥密码算法，它的特点是所需的密钥长度比RSA短。**椭圆曲线密码是通过将椭圆曲线上特定点进行特殊的乘法运算类事先的，它利用了这种乘法运算的逆运算非常困难的这一特性**

# 分组密码模式

## 分组密码与流密码

密码算法可分为**分组密码**和**流密码**两种

- 分组密码是每次只能处理特定长度的一块数据的一类密码算法，这里的“一块”成为分组（block）。此外，一个分组的比特数称为**分组长度**
	例如，DES与3DES分组长度都是64比特，这些密码算法一次只能加密64比特的明文，并生成64比特的密文，AES分组长度为128比特，因此AES一次可加密128比特的明文，并生成128比特的密文
- 流密码是对数据流进行连续处理的一类密码算法。流密码中一班以1比特、8比特、32比特等单位进行加密和解密

分组密码处理完一个分组就结束了，因此**不需要通过内部状态类记录加密的进度**；相对的，流密码是对一串数据流进行连续处理，因此**需要保持内部状态**。对于分组密码来说，需要对分组密码进行迭代，以便将很长的明文全部加密，而迭代的方法就称为分组密码的**模式（model）**

## 分组密码模式比较表

模式 | 名称 | 优点 | 缺点 | 备注
--|--|--|--|--
ECB模式 | Electronic CodeBook 电子密码本模式 | 简单；快速；支持并行计算（加密、解密） | 明文中的重复排列会反应在密文中；通过删除、替换密文分组可以对明文进行操作；对包含某些比特错误的密文进行解密时，对应的分组会出错；不能抵御重放攻击 | 不应使用
CBC模式 | Cipher Block Chaining 密文分组链接模式 | 明文的重复排列不会反应在密文中；支持并行计算（仅解密）；能够解密任意密文分组 | 对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错；加密不支持并行计算 | CRYPTREC推荐；《实用密码学》推荐
CFB模式 | Cipher-FeedBack密文反馈模式 | 不需要填充（padding）；支持并行计算（仅解密）；能解密任意密文分组 | 加密不支持并行计算；对包含某些错误比特的密文进行解密时，第一个分组的相应比特以及后一个分组的全部比特会出错；不能抵御重放攻击（这样来说CBC应该也不能抵御重放攻击） | CRYPTREC推荐
OFB模式 | Output-FeedBack输出反馈模式 | 不需要填充（padding）；可事先进行加密、解密的准备；加密、解密使用相同的结构；对包含某些错误比特的密文进行解密时，只有明文中相应的比特会出错 | 不支持并行计算；主动攻击者反转密文分组中的某些比特时，明文分组中相应的比特也会被反转 | CRYPTREC推荐
CTR模式 | CounTeR计数器模式 | 不需要填充（padding）；可事先进行加密、解密的准备；加密解密使用相同的结构；对包含某些错误比特的密文进行解密时，只有明文中相应的比特会出错；支持并行计算（加密、解密） | 主动攻击者反转密文分组中的某些比特时，明文分组中相应的比特也会被反转 | CRYPTREC推荐；《实用密码学》推荐

## ECB模式：Electronic CodeBook mode（电子密码本模式）（危险）

**将明文分割成多个分组并逐个加密的方法称为ECB模式**，这种模式非常简单但由于存在弱点，因此通常不会被使用

![](/images/Sat-Nov-17-20:47:40-2018_388563.jpg)

![](/images/Sat-Nov-17-20:51:22-2018_717153.jpg)

##### 对ECB模式的攻击

由于ECB模式中明文分组与密文分组都是一一对应关系，因此如果明文中存在多个相同的明文分组，这些明文分组都将被转换为相同的密文分组，这样一来，观察一下密文，就可知道明文中存在怎样的重复组合，并可以以此为线索来破译密码

**甚至都不需要破解密码，直接通过颠倒、复制、删除密文分组就可以改变相应的明文分组**

## CBC模式：Cipher Block Chaining mode（密码分组链接模式）

CBC模式全称是Cipher Block Chaining模式（密文分组链接模式），之所以叫这个名字是因为密文分组像链条一样互相连接在一起。**在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后在进行加密**。SSL/TLS
就是使用CBC模式来确保通信的机密性的

![](/images/Sat-Nov-17-23:26:35-2018_611064.jpg)

![](/images/Sat-Nov-17-23:30:01-2018_600495.jpg)

##### 对CBC的攻击

- CBC字节反转
	攻击者可以通过对初始化向量中的任意比特进行反转（1变0，0变1）来修改明文分组中对应的比特位。不过虽然攻击者可以对初始化向量进行攻击，但是想要对密文分组也进行相同的攻击就比较困难了，比如将密文分组1中某个比特进行了反转，则明文分组2中对应的比特对被反转，但是这1比特会对明文分组1中的多个比特造成影响
- 填充提示攻击
	填充提示攻击是一种利用分组密码中的**填充部分**进行攻击的方法。在填充提示攻击中，攻击者会反复发送一段密文，每次发送时都对填充的数据进行少许改变。由于接收者（服务器）在无法正确解密时会返回一个错误的消息，攻击者通过这一错误消息就可以获得一部分与明文相关的信息。这种攻击方式并不仅仅局限与CBC模式，而是**适用于所有需要进行分组填充的模式**。2014年对SSL3.0造成重大影响的POODLE攻击实际上就是一种填充提示攻击。要防御这种攻击需要**对密文进行认证，确保这段密文的确是由合法的发送者在知道明文内容的前提下生成的**
- 对初始化向量（IV）进行攻击
	初始化向量（IV）必须使用不可预测的随机数，而在SSL/TLS的TLS1.0版本协议中，IV并没有使用不可预测的随机数，而是使用了上一次CBC模式加密时的最后一个分组。为了防御攻击者对此攻击，TLS1.1以上的版本为了必须显示地传送IV（RFC5246 6.2.3.2）

## CFB模式：Cipher FeedBack mode（密文反馈模式）

CFB全称 Cipher FeedBack 模式（密文反馈模式）。在CFB中，**前一个密文分组会被送到密码算法的输入端**

![](/images/Sun-Nov-18-16:33:06-2018_505386.jpg)

![](/images/Sun-Nov-18-16:33:19-2018_277882.jpg)

可以看到，在CFB模式下，明文分组与密文分组之间并没有“加密”这一步骤，在CFB模式下，明文分组与密文分组之间只有一个XOR

![CBC与CFB对比](/images/Sun-Nov-18-16:44:04-2018_352632.jpg "CBC与CFB对比")

可以看到，CFB模式与“一次性密码本”有点相似。一次性密码本通过将“明文”与“随机比特序列”进行XOR运算来生成“密文”，而CFB模式通过“明文分组”与“密码算法的输出”进行XOR运算来生成“密文分组”，两者都通过XOR来进行加密。不过CFB中的“密码算法的输出”是通过计算得到的，与“一次性密码本”的“随机比特序列”还是有一些差别的。

CFB模式中由算法生成的比特序列称为**密钥流**，在CFB模式中，密钥算法相当于用来生成密钥流的伪随机数生成器，而初始化向量相当于伪随机数生成器的种子。在CFB模式中，明文数据可以被逐比特加密，因此我们可以将CFB模式看作是**一种使用分组密码来实现流密码**的方式

##### 对CFB模式的攻击

与CBC、ECB类似，对CFB模式仍可实施**重放攻击**

比如：A向B发送一条消息，这条消息由4个密文分组组成。攻击者M将该消息的后3个密文分组保存下来。转天，A又向B发送了内容不同的4个密文分组（假设A使用了相同的密钥）。这时M就可以用昨天保存下来的3个密文分组及那个今天发送的后三个密文分组进行替换。于是B解密的时候，只有第1个分组可以被解密成正确的明文分组，第2个分组会出错（无法判断是通信错误还是人为攻击），第3、4个分组已经变成了M替换的内容

## OFB模式：Output FeedBack mode（输出反馈模式）

OFB模式的全称是Output-Feedback模式（输出反馈模式）。在OFB中，密码算法的输出会反馈到密码算法的输入中

![](/images/Sun-Nov-18-17:34:26-2018_665775.jpg)

![](/images/Sun-Nov-18-17:37:16-2018_391875.jpg)

OFB与CFB还是有些类似的，可以对比下：

- CFB
	**密文分组**被反馈到加密算法的输入，因此称为CFB（密文反馈）
- OFB
	**加密算法的输出**被反馈到加密算法的输入，因此称为OFB（输出反馈）

不同于CFB模式，加密明文时需要用到前一个的密文分组数据，在OFB模式中，只需要密钥流既可以生成对应分组的密文。XOR所需要的密钥流可以事先通过密码算法生成，与明文数据无关。而XOR的速度与AES等密码算法相比时非常快的，所以只要提前准备好密钥流就可以快速完成加密。换个角度看，生成密钥流的操作与进行XOR运算的操作是可以并行的

## CTR模式：CounTeR mode（计数器模式）

CTR模式全称是CounTeR模式（计数器模式）。**CTR模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码**

![](/images/Sun-Nov-18-18:03:47-2018_556747.jpg)

![](/images/Sun-Nov-18-18:04:01-2018_314504.jpg)

##### 计数器生成方法

每次加密都会生成一个不同的值（nonce）来作为计数器的初始值。当分组长度为128比特（16字节）时，计数器形式大概如下：

![CTR计数器](/images/Sun-Nov-18-18:20:15-2018_792903.jpg "CTR计数器")

##### OFB与CTR的对比

CTR与OFB模式一样都属于流密码。OFB模式是将**加密的输出**反馈到输入，而CTR模式是将**计数器**的值用作输入

对于CTR模式来说，在加密和解密时需要用到的“计数器”可以由nonce和分组序号直接计算出来，而在OFB模式中需要依次算出来，这一性质是OFB所不具备的

# 密码结构

## Feistel网络

DES的基本结构是由Horst Feistel设计的，因此也成为Feistel网络、Feistel结构或Feistel密码。这一结构不仅被用于DES，在其他密码算法中也有应用

Feistel网络中，加密的各个步骤成为**轮（round）**，整个加密过程就是若干次轮的循环

# 分析方式

## 差分分析

差分分析是一种针对**分组密码**的分析方法，其思路是**“改变一部分明文并分析其密文如何随之改变”**。理论上来说，即便明文只改变一个比特，密文的比特排列也应该发生彻底的改变。可以通过分析密文改变中所产生的偏差来获取破解密码的线索

## 线性分析

由松井充提出，其思路是**“将明文和密文的一些对应比特进行XOR并计算其结果为零的概率”**。如果密文足够随机，则任选一些明文和密文的对应比特进行XOR结果为零的概率应该为1/2。如果能找到大幅偏离1/2的部分，就可以借此获得一些与密钥有关的信息。使用线性分析法对于DES只需要2^47组明文和密文就能完成破解，相比需要2^56个密钥的暴力破解来说，所需的计算量大幅减小

不过差分分析和线性分析都有一个前提，那就是**密码破译者可以选择任意明文并得到其加密的结果**，这种攻击方式称为**选择明文攻击（Chosen Plaintext Attach，CPA）**。以AES为代表的现代分组算法在设计上已经考虑了针对差分分析和线性分析的安全性。

